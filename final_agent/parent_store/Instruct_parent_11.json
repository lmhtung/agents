{
  "page_content": "### Step 10: Build the LangGraph Graphs  \nAssemble the complete workflow graph with conversation memory and multi-agent architecture.  \n```python\nfrom langgraph.graph import START, END, StateGraph\nfrom langgraph.prebuilt import ToolNode\nfrom langgraph.checkpoint.memory import InMemorySaver\n\ncheckpointer = InMemorySaver()\n\nagent_builder = StateGraph(AgentState)\nagent_builder.add_node(orchestrator)\nagent_builder.add_node(\"tools\", ToolNode([search_child_chunks, retrieve_parent_chunks]))\nagent_builder.add_node(compress_context)\nagent_builder.add_node(fallback_response)\nagent_builder.add_node(should_compress_context)\nagent_builder.add_node(collect_answer)\n\nagent_builder.add_edge(START, \"orchestrator\")\nagent_builder.add_conditional_edges(\"orchestrator\", route_after_orchestrator_call, {\"tools\": \"tools\", \"fallback_response\": \"fallback_response\", \"collect_answer\": \"collect_answer\"})\nagent_builder.add_edge(\"tools\", \"should_compress_context\")\nagent_builder.add_edge(\"compress_context\", \"orchestrator\")\nagent_builder.add_edge(\"fallback_response\", \"collect_answer\")\nagent_builder.add_edge(\"collect_answer\", END)\nagent_subgraph = agent_builder.compile()\n\ngraph_builder = StateGraph(State)\ngraph_builder.add_node(summarize_history)\ngraph_builder.add_node(rewrite_query)\ngraph_builder.add_node(request_clarification)\ngraph_builder.add_node(\"agent\", agent_subgraph)\ngraph_builder.add_node(aggregate_answers)\n\ngraph_builder.add_edge(START, \"summarize_history\")\ngraph_builder.add_edge(\"summarize_history\", \"rewrite_query\")\ngraph_builder.add_conditional_edges(\"rewrite_query\", route_after_rewrite)\ngraph_builder.add_edge(\"request_clarification\", \"rewrite_query\")\ngraph_builder.add_edge([\"agent\"], \"aggregate_answers\")\ngraph_builder.add_edge(\"aggregate_answers\", END)\n\nagent_graph = graph_builder.compile(checkpointer=checkpointer, interrupt_before=[\"request_clarification\"])\n```  \n**Graph architecture explained:**  \nThe architecture flow diagram can be viewed **[here](./assets/agentic_rag_workflow.png)**.  \n**Agent Subgraph** (processes individual questions):\n- START → `orchestrator` (invoke LLM with tools)\n- `orchestrator` → `tools` (if tool calls needed) OR `fallback_response` (if budget exhausted) OR `collect_answer` (if done)\n- `tools` → `should_compress_context` (check token budget)\n- `should_compress_context` → `compress_context` (if threshold exceeded) OR `orchestrator` (otherwise)\n- `compress_context` → `orchestrator` (resume with compressed memory)\n- `fallback_response` → `collect_answer` (package best-effort answer)\n- `collect_answer` → END (clean final answer with index)  \n**Main Graph** (orchestrates complete workflow):\n- START → `summarize_history` (extract conversation context from history)\n- `summarize_history` → `rewrite_query` (rewrite query with context, check clarity)\n- `rewrite_query` → `request_clarification` (if unclear) OR spawn parallel `agent` subgraphs via `Send` (if clear)\n- `request_clarification` → `rewrite_query` (after user provides clarification)\n- All `agent` subgraphs → `aggregate_answers` (merge all responses)\n- `aggregate_answers` → END (return final synthesized answer)  \n---",
  "metadata": {
    "H2": "Implementation",
    "H3": "Step 10: Build the LangGraph Graphs",
    "source": "Instruct.pdf",
    "parent_id": "Instruct_parent_11"
  }
}